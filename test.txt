; =========================
; POINTERS (absolute addrs)
; =========================
LOC 6
Data 64      ; [6]  -> base of CONSTS (X1)
Data 96      ; [7]  -> base of SCR    (X3)
Data 128     ; [8]  -> base of ARR
Data 512     ; [9]  -> READ_INT page 0 base
Data 576     ; [10] -> PRINT_INT push page base
Data 256     ; [11] -> main code base (not strictly needed)
Data 263     ; [12] -> READ loop head (main)
Data 276     ; [13] -> PRINT loop head (main)
Data 300     ; [14] -> SCAN loop head (main)
Data 0       ; [15] -> spare
Data 544     ; [16] -> READ_INT page 1 (digits/finalize)
Data 608     ; [17] -> PRINT_INT pop page

; =========================
; CONSTANTS (via X1 window)
; =========================
LOC 64
Data 48      ; [64+0]  '0'
Data 57      ; [64+1]  '9'
Data 32      ; [64+2]  ' '
Data 10      ; [64+3]  LF
Data 13      ; [64+4]  CR
Data 45      ; [64+5]  '-'
Data 1       ; [64+6]  +1
Data 10      ; [64+7]  10 (not required, kept for convenience)
Data 0       ; [64+8]  0
Data 32767   ; [64+9]  +32767

; =========================
; SCRATCH (via X3 window)
; =========================
; offsets relative to X3 (96)
;  [0]  ARR_PTR
;  [1]  RVAL/TARGET (READ_INT writes result here)
;  [2]  TMP/DIGIT
;  [3]  TMP2 / DIFF / VALUE_SAVE
;  [4]  MINDIFF
;  [5]  BESTVAL
;  [6]  SIGN  (+1 or -1)
;  [7]  CHAR  (last input char)
;  [8]  DIGCOUNT
;  [9..14] DIGBUF[0..5]
;  [15] DIGPTR  (pointer used by PRINT)
LOC 96
Data 128     ; [96+0]  ARR_PTR initial -> &ARR
Data 0       ; [96+1]
Data 0       ; [96+2]
Data 0       ; [96+3]
Data 0       ; [96+4]
Data 0       ; [96+5]
Data 1       ; [96+6] SIGN=+1
Data 0       ; [96+7] CHAR
Data 0       ; [96+8] DIGCOUNT
Data 0       ; [96+9]
Data 0       ; [96+10]
Data 0       ; [96+11]
Data 0       ; [96+12]
Data 0       ; [96+13]
Data 0       ; [96+14]
Data 0       ; [96+15] DIGPTR

; =========================
; ARRAY of 20 integers
; =========================
LOC 128
Data 0
Data 0
Data 0
Data 0
Data 0
Data 0
Data 0
Data 0
Data 0
Data 0
Data 0
Data 0
Data 0
Data 0
Data 0
Data 0
Data 0
Data 0
Data 0
Data 0

; =========================
; MAIN PROGRAM
; =========================
LOC 256
; -- set up index base registers X1/X3
LDX 1,6            ; X1 <- 64 (CONSTS base)
LDX 3,7            ; X3 <- 96 (SCR base)

; -- ARR_PTR <- &ARR
LDR 1,0,8          ; R1 <- 128
STR 1,3,0          ; SCR[0] = ARR_PTR

; -------- read 20 integers into ARR --------
LDA 2,0,0          ; R2 = 0
AIR 2,20           ; R2 = 20
LDX 2,12           ; X2 <- 263 (READ loop head)

; [263] READ loop head:
LDX 2,9            ; X2 <- 512 (READ_INT page 0)
JSR 2,0            ; call READ_INT (writes result in SCR[1])
LDR 0,3,1          ; R0 <- SCR[1] (value just read)
STR 0,3,0,1        ; *ARR_PTR = R0   (indirect via SCR[0])
LDR 1,3,0          ; R1 = ARR_PTR
AIR 1,1            ; ++
STR 1,3,0          ; save ARR_PTR
LDX 2,12           ; restore X2 to loop-head base (263)
SOB 2,2,0          ; --R2; if >0 jump to 263

; -------- echo the 20 integers --------
LDR 1,0,8          ; R1 <- 128
STR 1,3,0          ; ARR_PTR <- &ARR
LDA 2,0,0
AIR 2,20
LDX 2,13           ; X2 <- 276 (PRINT loop head)

; [276] PRINT loop head:
LDR 0,3,0,1        ; R0 = *ARR_PTR
LDX 2,10           ; X2 <- 576 (PRINT push page)
JSR 2,0            ; print R0 (decimal)
LDR 1,1,2          ; ' '
OUT 1,1            ; space
LDR 1,3,0          ; ARR_PTR
AIR 1,1
STR 1,3,0
LDX 2,13
SOB 2,2,0          ; loop 20
LDR 1,1,3          ; LF
OUT 1,1

; -------- read target --------
LDX 2,9
JSR 2,0            ; READ_INT -> SCR[1]
LDR 0,3,1          ; R0 = target (optional copy)
STR 0,3,1          ; ensure SCR[1] holds target

; -------- find closest --------
LDR 1,1,9          ; R1 = +32767
STR 1,3,4          ; MINDIFF
LDR 1,1,8          ; R1 = 0
STR 1,3,5          ; BESTVAL
LDR 1,0,8          ; R1 <- &ARR
STR 1,3,0          ; ARR_PTR <- base
LDA 2,0,0
AIR 2,20
LDX 2,14           ; X2 <- 300 (SCAN loop head)

; [300] SCAN loop head:
LDR 1,3,0,1        ; R1 = *ARR_PTR          (a[i])
STR 1,3,2          ; SCR[2] <- a[i]
LDR 0,3,1          ; R0 = target
SMR 0,3,2          ; R0 = target - a[i]
STR 0,3,3          ; SCR[3] <- diff
JGE 0,2,9          ; if diff >= 0 jump to 309
LDA 1,0,0          ; R1 = 0
SMR 1,3,3          ; R1 = -diff
STR 1,3,3          ; SCR[3] = |diff|
; [309]
LDR 1,3,3          ; R1 = |diff|
SMR 1,3,4          ; R1 = |diff| - MINDIFF
JGE 1,2,16         ; if >=0 no update -> 316
LDR 0,3,3          ; R0 = |diff|
STR 0,3,4          ; MINDIFF = |diff|
LDR 0,3,2          ; R0 = a[i]
STR 0,3,5          ; BESTVAL = a[i]
; [316]
LDR 1,3,0          ; ARR_PTR
AIR 1,1
STR 1,3,0
LDX 2,14
SOB 2,2,0          ; next i

; -------- output: "<target> <closest>\n" --------
LDR 0,3,1          ; R0 = target
LDX 2,10
JSR 2,0
LDR 1,1,2
OUT 1,1            ; space
LDR 0,3,5          ; R0 = best (closest)
LDX 2,10
JSR 2,0
LDR 1,1,3
OUT 1,1
HLT

; =========================
; READ_INT (page 0): skip blanks, handle optional minus, jump to page 1
;   On return: value is stored in SCR[1]; RFS 0 used
; =========================
LOC 512
LDA 0,0,0          ; R0 = 0 (accumulator)
LDR 1,1,6          ; R1 = +1
STR 1,3,6          ; SIGN = +1
IN 1,0             ; read char
STR 1,3,7          ; CHAR
LDR 1,3,7
SMR 1,1,2          ; ch - ' '
JZ 1,2,3           ; -> re-read at 515
LDR 1,3,7
SMR 1,1,3          ; ch - LF
JZ 1,2,3
LDR 1,3,7
SMR 1,1,4          ; ch - CR
JZ 1,2,3
LDR 1,3,7
SMR 1,1,5          ; ch - '-'
JNE 1,2,23         ; if not '-', proceed to digits page
LDA 1,0,0          ; build -1 for SIGN
SMR 1,1,6
STR 1,3,6
IN 1,0             ; read next char
STR 1,3,7
LDX 2,16           ; X2 <- 544 (digits page)
JMA 2,0            ; goto 544
; re-read anchor at 515 (512+3):
IN 1,0
STR 1,3,7
; then flow continues with the 512+5 tests again (space/LF/CR) as above
; (falls through these same instructionsâ€”already in this page)

; =========================
; READ_INT (page 1): digits loop + finalize
;   Base = 544, X2 assumed = 544
; =========================
LOC 544
LDR 1,3,7          ; head: CHAR
SMR 1,1,0          ; ch - '0'
JGE 1,2,4          ; if >=0 -> check '9'
JMA 2,21           ; else -> finalize (565)
LDR 1,1,1          ; '9'
SMR 1,3,7          ; '9' - ch
JGE 1,2,8          ; if >=0 -> accumulate
JMA 2,21           ; else -> finalize

; accumulate:
LDR 1,3,7
SMR 1,1,0          ; R1 = digit
STR 1,3,2          ; SCR[2] = digit
STR 0,3,3          ; save old value
SRC 0,3,1,1        ; R0 <<= 3 (value*8)
LDR 1,3,3
SRC 1,1,1,1        ; R1 <<= 1 (old*2)
STR 1,3,3
AMR 0,3,3          ; R0 += old*2  (value*10)
AMR 0,3,2          ; R0 += digit
IN 1,0             ; next char
STR 1,3,7
JMA 2,0            ; back to head

; finalize:
LDR 1,3,6          ; SIGN
JGE 1,2,26         ; if >=0 -> store/return
STR 0,3,2          ; save value
LDA 0,0,0
SMR 0,3,2          ; R0 = -value
STR 0,3,1          ; store result in SCR[1]
RFS 0              ; return

; (if sign >=0)
STR 0,3,1          ; store result
RFS 0

; =========================
; PRINT_INT (page 0, base 576): push digits to DIGBUF
;   Entry: R0 has value to print
;   Uses: R2=10, R1 for remainder/ASCII
;   On return: via page 1 (608) which pops digits and prints; returns with RFS 0
; =========================
LOC 576
JGE 0,2,3          ; if R0 >= 0 skip minus
LDR 1,1,5          ; '-'
OUT 1,1
STR 0,3,2
LDA 0,0,0
SMR 0,3,2          ; R0 = -R0
LDA 2,0,0
AIR 2,10           ; R2 = 10
LDA 1,0,0
STR 1,3,8          ; DIGCOUNT = 0
LDA 1,3,9          ; R1 = &DIGBUF[0]
STR 1,3,15         ; DIGPTR = base

; push loop:
LDA 1,0,0          ; R1=0 high half for DVD
DVD 0,2            ; (R0:R1)/10 -> R0=quotient, R1=remainder
STR 1,3,2          ; save remainder
LDR 1,3,2
AMR 1,1,0          ; R1 += '0'
STR 1,3,15,1       ; *DIGPTR = ASCII digit
LDR 1,3,15
AIR 1,1
STR 1,3,15         ; DIGPTR++
LDR 1,3,8
AIR 1,1
STR 1,3,8          ; DIGCOUNT++
JNE 0,2,12         ; if quotient != 0, loop to push head (576+12)

; jump to pop page
LDX 2,17           ; X2 <- 608
JMA 2,0            ; goto pop page

; =========================
; PRINT_INT (page 1, base 608): pop digits in reverse and OUT
; =========================
LOC 608
LDR 1,3,8          ; count
JZ 1,2,12          ; if 0 -> return (base+12=620)
LDR 0,3,15         ; PTR
SIR 0,1
STR 0,3,15         ; PTR = PTR - 1
LDR 1,3,15,1       ; ch = *PTR
OUT 1,1
LDR 1,3,8
SIR 1,1
STR 1,3,8          ; --count
JNE 1,2,0          ; if count != 0 -> loop to base 608
RFS 0              ; return
